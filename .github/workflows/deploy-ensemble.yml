name: Deploy Ensemble ML to Azure (Cost-Optimized)

on:
  push:
    branches: [main]
    paths:
      - 'Dockerfile'
      - 'requirements*.txt'
      - 'src/**'
      - '.github/workflows/deploy-ensemble.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

env:
  REGISTRY: cultivatemlacr.azurecr.io
  IMAGE_NAME: cultivate-ml-api
  RESOURCE_GROUP: cultivate-rg

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Login to Azure
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Login to ACR
      uses: azure/docker-login@v1
      with:
        login-server: ${{ env.REGISTRY }}
        username: ${{ secrets.ACR_USERNAME }}
        password: ${{ secrets.ACR_PASSWORD }}

    - name: Build and push Docker image
      run: |
        IMAGE_TAG="${{ github.event.inputs.environment || 'staging' }}-${{ github.sha }}"

        # Build the fullml stage with ensemble support
        docker build \
          --target fullml \
          --tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG} \
          --tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest \
          .

        # Push both tags
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG}
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest

        echo "IMAGE_TAG=${IMAGE_TAG}" >> $GITHUB_ENV

    - name: Deploy to Container Apps (Cost-Optimized)
      run: |
        ENVIRONMENT="${{ github.event.inputs.environment || 'staging' }}"
        APP_NAME="cultivate-ml-${ENVIRONMENT}"

        # Check if Container App exists
        APP_EXISTS=$(az containerapp show \
          --name ${APP_NAME} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --query name -o tsv 2>/dev/null || echo "")

        if [ -z "$APP_EXISTS" ]; then
          echo "Creating new Container App with minimal resources..."

          # Create Container App Environment if it doesn't exist
          ENV_EXISTS=$(az containerapp env show \
            --name cultivate-env \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query name -o tsv 2>/dev/null || echo "")

          if [ -z "$ENV_EXISTS" ]; then
            az containerapp env create \
              --name cultivate-env \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --location eastus
          fi

          # Create minimal Container App (cost-optimized for MVP)
          az containerapp create \
            --name ${APP_NAME} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --environment cultivate-env \
            --image ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} \
            --target-port 8000 \
            --ingress external \
            --cpu 0.25 \
            --memory 0.5Gi \
            --min-replicas 0 \
            --max-replicas 1 \
            --registry-server ${{ env.REGISTRY }} \
            --registry-username ${{ secrets.ACR_USERNAME }} \
            --registry-password ${{ secrets.ACR_PASSWORD }} \
            --env-vars \
              MODEL_TYPE=ensemble \
              USE_AZURE_STORAGE=true \
              AZURE_STORAGE_CONNECTION_STRING="${{ secrets.AZURE_STORAGE_CONNECTION }}" \
              ENVIRONMENT=${ENVIRONMENT} \
              REDIS_ENABLED=false \
              MODEL_DOWNLOAD_ON_STARTUP=false
        else
          echo "Updating existing Container App..."

          # Update with new image
          az containerapp update \
            --name ${APP_NAME} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --image ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
        fi

        # Get application URL
        APP_URL=$(az containerapp show \
          --name ${APP_NAME} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --query properties.configuration.ingress.fqdn -o tsv)

        echo "### ðŸš€ Deployment Complete!" >> $GITHUB_STEP_SUMMARY
        echo "**Environment:** ${ENVIRONMENT}" >> $GITHUB_STEP_SUMMARY
        echo "**URL:** https://${APP_URL}" >> $GITHUB_STEP_SUMMARY
        echo "**Image:** ${{ env.IMAGE_TAG }}" >> $GITHUB_STEP_SUMMARY

    - name: Health Check
      run: |
        ENVIRONMENT="${{ github.event.inputs.environment || 'staging' }}"
        APP_NAME="cultivate-ml-${ENVIRONMENT}"

        APP_URL=$(az containerapp show \
          --name ${APP_NAME} \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --query properties.configuration.ingress.fqdn -o tsv)

        # Wait for deployment to be ready
        echo "Waiting for deployment to be ready..."
        sleep 60

        # Check health endpoint
        HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" https://${APP_URL}/api/health || echo "000")

        if [ "$HTTP_CODE" == "200" ]; then
          echo "âœ… Health check passed!" >> $GITHUB_STEP_SUMMARY
        else
          echo "âš ï¸ Health check returned: $HTTP_CODE" >> $GITHUB_STEP_SUMMARY
        fi